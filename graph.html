<!doctype html>
<html lang="en">
  <!-- vim:set et ts=2 sw=2 sts=2: -->
  <head>
    <meta charset="utf-8">
    <title>演算法／陳伯恩</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <style>
      table.centertable td, table.centertable th { text-align: center; }
      .reveal sup, .reveal sub { font-size: 75%; } strong { color: #f99; }
      table.boxed { border-collapse: collapse; }
      table.boxed td { border: 2px solid silver; }
      table.boxed td.noboxed { border-width: 0; }
    </style>
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>演算法＋圖論</h1>
          <p>2014/12/28 陳伯恩</p>
          <p><a href="http://betaveros.github.io/2014-algo/graph.html"><code>http://betaveros.github.io/2014-algo/graph.html</code></a></p>
          <p>(created with reveal.js-2.6.2)</p>
        </section>
        <section>
          <h2>先宣傳一下</h2>
          <h2><a href="http://ioicamp.csie.org/">2015 程式解題競賽集訓營</a></h2>
          <p>謀事在人，程式在天 (<code>ioicamp.csie.org</code>)</p>
        </section>
        <section>
          <section>
            <h2>Graph 圖</h2>
            <img src="graph6.png" alt="[A graph with 6 vertices and 7 edges]" width="640" height="423"/>
          </section>
          <section>
            <h2>Graph 圖</h2>
            <p>G = (V, E)</p>
            <p>就是一堆<strong>（頂）點</strong>，跟一堆<strong>邊</strong>。</p>
            <p>每條<strong>邊</strong>連接兩個點。</p>
            <p>方向（即一個A到B的邊跟一個B到A的邊一不一樣）有時候重要，有時候不重要。重要的時候，是<strong>有向圖</strong>；不重要的時候，是<strong>無向圖</strong></p>
          </section>
          <section>
            <h2>如何儲存？</h2>
            <p>幾乎所有時候，頂點會有數字標記。</p>
            <p>邊也會有性質（權重、長度、價格、價值，分數⋯⋯）</p>
            <p class="reveal"><code>vector&lt;pair&lt;int,int&gt; &gt;</code>？</p>
            <p class="reveal"><code>set&lt;pair&lt;int,int&gt; &gt;</code>？</p>
            <p class="reveal">應該先問，我們可能會如何使用儲存的圖？</p>
            <ul>
              <li class="reveal">詢問一個點有邊到那些其他點（＋那些邊的性質）</li>
              <li class="reveal">詢問兩個點之間有沒有邊（＋那些邊的性質）</li>
            </ul>
          </section>
          <section>
            <h2>最常用的方法</h2>
            <code>vector&lt;int&gt; graph[500008];</code>
            <p><code>graph[i]</code>包含所有從頂點<code>i</code>出發的邊到另外哪一個頂點</p>
            <p>如果邊上還要儲存其他資訊，可以用：</p>
            <pre><code data-trim class="cpp">
struct Edge { int to; int dist; };
vector&lt;Edge&gt; graph[500008];

// ...
    scanf("%d%d%d", &amp;a, &amp;b, &amp;d);
    graph[a].push_back(Edge { .to = b, .dist = d });
// ...
            </code></pre>
          </section>
          <section>
            <h2>另外</h2>
            <p>點很少／邊很多／需要計算每兩個點之間的東西（All-Pairs Shortest Paths）的話：</p>
            <pre><code data-trim class="cpp">
const int OO = 2000 &lt;&lt; 20;
int dist[1008][1008];
for (int i = 0; i &lt; 1008; i++)
    for (int j = 0; j &lt; 1008; j++)
        dist[i][j] = OO;

// ...
    scanf("%d%d%d", &amp;a, &amp;b, &amp;d);
    dist[a][b] = min(dist[a][b], d);
// ...
            </code></pre>
          </section>
          <section>
            <h2>最後</h2>
            <p><code>vector&lt;Edge&gt;</code>也是有用的（Kruskal）</p>
          </section>
        </section>
        <section>
          <h2>例子</h2>
          <p>因為我不會找題目，所以一半是靠CodeForces的tag，一半是靠</p>
          <pre><code data-trim class="sh">
ack graph --cpp --files-with-matches | xargs mvim
          </code></pre>
          <p>一起做一個例子吧：<a href="http://codeforces.com/problemset/problem/300/B">CF R181 D2 pB. Coach</a></p>
        </section>
        <section>
          <section>
            <h2>Depth-First Search (DFS)</h2>
            <p>最輕鬆但也最重要的演算法。看到節點就走下去遞迴。</p>
            <a href="http://www.cs.usfca.edu/~galles/visualization/DFS.html">DFS Visualization</a>
            <p>只需要記錄一個bool陣列，而且如果是Tree的話連這個都不用。</p>
            <pre><code data-trim class="cpp">
void dfs(int v) {
    if (vis[v]) return;
    vis[v] = true;
    for (int w : graph[v]) dfs(w);
}
            </code></pre>
            <p>（＊除非遞迴太深，要「手爆stack」）</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Tree</h2>
          </section>
          <section>
            <h2>Tree 性質</h2>
            <ul>
              <li>n個點，n &minus; 1條邊</li>
              <li>連通</li>
              <li>沒有圈</li>
            </ul>
            <p>（有人叫n個點，n條邊＋連通（＋恰一個圈）的圖「水母」）</p>
            <a href="http://codeforces.com/problemset/problem/103/B">CF β R80 pB. Cthulhu</a>
          </section>
          <section>
            <h2>Tree 性質</h2>
            <p>題目常見的一種tree表示法是給你n &minus; 1個數字，0 ≤ a<sub>i</sub> &lt; i，a<sub>i</sub>表示節點i連到a<sub>i</sub>。這樣也很自然的出現root，就是節點0。</p>
            <ul>
              <li><a href="http://codeforces.com/problemset/problem/429/A">CF R245 D1 pA. Xor-tree</a></li>
              <li><a href="http://codeforces.com/problemset/problem/115/A">CF β R87 pA. Party</a></li>
            </ul>
          </section>
          <section>
            <ul>
              <li><a href="http://codeforces.com/problemset/problem/129/B">CF β R94 pB. Students and Shoelaces</a></li>
              <li><a href="https://code.google.com/codejam/contest/2984486/dashboard#s=p1">GCJ 2014 R1A pB. Full Binary Tree</a></li>
              <li><a href="http://hoj.twbbs.org/judge/problem/view/135">HOJ 135. 縫紉課</a></li>
              <li><a href="http://hoj.twbbs.org/judge/problem/view/113">HOJ 113. 計步器</a></li>
              <li><a href="http://codeforces.com/problemset/problem/429/A">CF R245 DI pA. Xor-tree</a></li>
              <li><a href="http://codeforces.com/contest/437/problem/D">CF R250 D2 pD / D1 pB. The Child and Zoo</a></li>
              <li><a href="http://codeforces.com/contest/238/problem/C">CF R148 D1 pC. World Eater Brothers</a></li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Grid</h2>
            <a href="http://codeforces.com/problemset/problem/377/A">CF R222 pA. Maze</a>
          </section>
        </section>
        <section>
          <section>
            <h2>Breadth-First Search (BFS)</h2>
          </section>
        </section>
        <section>
          <section>
            <h2>其他Search</h2>
            <p>A*?</p>
            <p>IDDFS</p>
            <p>...</p>
          </section>
        </section>
        <section>
          <section>
            <h2>Disjoint-Set Union</h2>
            <p>雖然這應該是資料結構上的東西，不過不知道要寫什麼</p>
            <ul>
              <li><a href="http://codeforces.com/problemset/problem/217/A">Codeforces R134 D1 pA. Ice Skating</a></li>
              <li><a href="http://codeforces.com/problemset/problem/277/A">Codeforces R170 D1 pA. Learning Languages</a></li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Topological Sort 拓撲排序</h2>
          </section>
          <section>
            <h2>Topological Sort 拓撲排序</h2>
          </section>
        </section>
        <section>
          <section>
            <h2>Single-Source Shortest Path</h2>
            <p>經典在<a href="http://hoj.twbbs.org/judge/problem/view/138">HOJ 138. 海綿寶寶之我要吃美味蟹堡(最短路)</a></p>
          </section>
          <section>
            <h2>Dijkstra</h2>
            <p>（超難念）</p>
          </section>
        </section>
        <section>
          <section>
            <h2>All-Pairs Shortest Path</h2>
          </section>
          <section>
            <h2>Floyd-Warshall</h2>
          </section>
        </section>
        <section>
          <section>
            <h2>Minimum Spanning Tree 最小生成樹</h2>
          </section>
          <section>
            <h2>Kruskal</h2>
          </section>
        </section>
        <section>
          <section>
            <h2>etc（略提）</h2>
          </section>
          <section>
            <h2>SCC</h2>
          </section>
          <section>
            <h2>Flow</h2>
          </section>
          <section>
            <h2>防防防防破台</h2>
            <a href="http://codeforces.com/contest/418/problem/D">CF RCC2014 D1 pD. Big Problems for Organizers</a>
          </section>
        </section>
      </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
controls: true,
progress: true,
history: true,
center: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

// Parallax scrolling
// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
// parallaxBackgroundSize: '2100px 900px',

// Optional libraries used to extend on reveal.js
dependencies: [
{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }
]
});
    </script>
    </body>
    </html>
